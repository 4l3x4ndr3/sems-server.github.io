<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>SEMS: DSM: State machine notation for VoIP applications</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">SEMS
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">DSM: <a class="el" href="classState.html">State</a> machine notation for VoIP applications </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="Readme_dsm"></a>
DSM Readme file</h2>
<div class="fragment"><pre class="fragment">
The DonkeySM - state machines as SEMS applications

DonkeySM is a state machine interpreter for SEMS. Application 
or service logic can comfortably and accurately be defined
as state machine, in a simple textual state machine definition 
language, and executed by the dsm module as application in SEMS.

A DSM consists of states and transitions between the states.
One state is the initial state with which the DSM is started. 
The transitions have conditions. If something happens, 
i.e. the session processes an event, the transitions are checked 
in order. If all conditions match, the transition is executed. 
Transitions can contain actions, which are run when the transition 
is executed. States can have actions that are executed on entering 
the state, and on leaving the state. If a transition is executed, 
first the leaving actions of the old state, then the transition 
actions, and finally the entering actions of the new state are 
executed.

DSMs can be defined in a hierarchical manner: Another DSM can be 
called as sub-DSM, or one can jump to another DSM, ignoring where
we came from.

In the DSM language, there is support for 
 - functions (groups of action commands)
 - if condition { action; action; } else { action; action; }
 - for loops: 
     - for ($x in range(0, 5)) { action; action; }
     - for ($x in $myarray) { action; action; }
     - for ($k,v in $mystruct) { action; action; }

A session (call) in the DonkeySM has a set of named (string) variables.
The variables may be used as parameter to most conditions and 
actions, by prepending the variable name with a dollar sign. The
parameters of an event (e.g. the key on key press) may be accessed
by prepending the name with a hash (e.g. #key). There are also 
'selects' with which a set of dialog properties can be accessed 
(e.g. @local_tag).

The DonkeySM can be extended by modules, which add new conditions
and actions to the language. This way, menuing system etc can be 
implemented as DSM, while complex logic or processing can efficitently 
be implemented in C++. Modules can act on new sessions, and have a 
initialization function that is called when the module is loaded.
DonkeySM also has built in actions to call 
DI methods from other modules. 

Actions (and conditions) can throw exceptions. Once an exception occurs,
execution of the current actions is interrupted. Exceptions are handled
this way that special "exception" transitions are executed. Exception
transitions are marked with "exception" in the conditions list. Once the
FSM is in exception handling, only exception transitions are followed.
DSMs may throw exceptions with the throw(&lt;type&gt;) action or the 
throwOnError() action.

DSM can cache a set of prompts, configured at start, in memory 
using PromptCollection.

A patch for fmsc 1.0.4 from the graphical FSM editor fsme 
(http://fsme.sf.net) is available, so DSMs can be defined in 
click-n-drag fashion and compiled to SEMS DSM diagrams.

DSM scripts can include other scripts by using the #include "script.dsm"
directive. That loads a script from the load path (where the current 
script resides), unless an absolute path is given (e.g. 
#include "/path/to/script).

There is SIP Session Timer (RFC4028) support, which is configured in 
dsm.conf. By default, session timers are turned not enabled.

SystemDSMs
==========

A system DSM is executed without a corresponding call. This can be useful 
e.g. to execute something periodically, to make a call generator etc.

Another use of system DSMs is to centralize application logic that spans
several calls. The call legs send updates in theirs states as events to
the central system DSM, which centrally processes those events and sends
commands as events back to the call legs, which then process those commands.

Obviously, only limited functionality is available in System DSMs, all 
call and media related functionality is not available (and will throw 
exceptions with type 'core').

A system DSM receives the "startup" event on start of the server, or if 
it is created via createSystemDSM DI call. It gets a "reload" event if the
system DSM is created by a live config reload.

On server shutdown, a system DSM receives a "system" event with 
"ServerShutdown" as type. 

See test_system_event.dsm example for an example how to handle server
start and reload.

DI commands
===========

DI commands allow interaction with DSM calls, and DSM script reload:

postDSMEvent(string call_id, [ [[param0,val0],[param1,val1],...] ]
 post a DSM event into a call. can be used to interact with running
 calls in DSM. See DSM + monitoring + DI example in 
 examples/dsm_di_monit. 

 Example: 
   s.postDSMEvent(call_id, [['action', 'take'],['roomname', 'realworld']])


reloadDSMs()
  reload all DSMs from config file (load_diags) from main config
  - DSM is loaded with main config

loadDSM(string diag_name)
  load DSM with name diag_name, paths are taken from config file
  - DSM is loaded with main config

loadDSMWithPaths(string diag_name, string diag_path, string mod_path)
  load DSM with specified paths
  - DSM is loaded with main config

preloadModules()
  preload all modules specified in config file (preload_mods)

preloadModule(string mod_name, string mod_path)
  preload module from specific path 

hasDSM(string diag_name, [string config])
  returns 1 if DSM with diag_name is loaded, 0 if not
  if config empty or not given, DSM of main config will be listed

listDSMs([string config])
  return list of loaded DSMs
  if config empty or not given, DSM of main config will be listed

registerApplication(string diag_name, [string config])
  register DSM with name diag_name as application in SEMS
  (e.g. to be used with application=$(apphdr), $(ruri.param) 
  or $(ruri.user)
  if config empty or not given, DSM is assumed to be in main config

loadConfig(string conf_file_name, string conf_name)
  (re)load application bundle ("app bundle"), configuration and scripts
  like a file in conf_dir

createSystemDSM(string conf_name, string start_diag)
  run a system DSM (i.e. a DSM thread not connected to a session)
  using scripts/configuration from conf_name. 
  conf_name=='main' for main scripts/main config (from dsm.conf)

More info
=========
 o doc/dsm_syntax.txt has a quick reference for dsm syntax
 o doc/examples/ and lib/ some example DSMs
 o doc/examples/dsm_di_monit example on interfacing with DSM
 o mods/ (will) have modules

Internals
=========
The DSMStateEngine has a set of DSM diagrams which are loaded by 
the DSMStateDiagramCollection from text file and interpreted by
the DSMChartReader, a simple stack based tokenizing compiler.

DSMCall, which implement the DSMSession interface (additionally
to being an AmSession), run DSMStateEngine::runEvent for every event 
that occurs that should be processed by the engine (e.g. Audio event, 
onBye, ...). 

The DSMStateEngine checks every condition of the active state whether
it matches. If all match, the exit actions of the current state, the 
transition actions and then the enter actions of the next state are 
executed. The DSMCondition::match and DSMAction::execute functions
get the event parameters and the session as parameters, so that they
can operate on variables, implement selects etc. 

The DSMCall implementation is very simple, it uses a playlist and 
has PromptCollection to simply play prompts etc.

DSMCoreModule is a 'built in' module that implements the basic 
conditions (test(), hangup() etc) and actions (set(), playFile(), DI 
etc).

Roadmap
=======

On the roadmap is the possibility for modules to be the session factory
used for creating the new session. As the DSMSession is mostly an abstract 
interface, other session types can easily be implemented, and their 
functionality be exposed to the DSM interpreter by custom actions and 
conditions that interact with that specific session type.

As the call state representation is nicely encapsulated here, this can 
also provide an abstraction layer on which active call replication can 
be implemented (rather than re-doing that for every application).

Q&amp;A
===

Why "Donkey" SM? 
 Thanks Atle for the name: "I dont know why.. but my first thought
 when I read good name for FSM interpreter was Donkey. The reason for the
 name is that you put alot of things ontop of a donkey, and let it carry
 it arround.. and this is the same.. you put loads of stuf ontop.. and it
 carries it."

What is repost()? 
 If an event should be reevaluated, e.g. by the transitions of another 
 state or the initial state of another DSM which is called with callFSM/ 
 jumpFSM, repost() can be called, which signals the interpreter to
 evaluate the current event again.

Is the diagram interpreted or compiled? 
 DonkeySM reads the DSM script and creates an internal representation 
 (DSM classes in STL containers). This way it can be executed very
 efficiently.

map&lt;string, string&gt; var; - Are you crazy? E stands for Express!
 yes, right, there would be more efficient ways to implement
 that.  Anyway, in my experience one mostly has to manipulate and 
 check strings, and it is just very comfortable to do it this way.
 OTOH, if in a normal call there is a transition maybe on average 
 every 10 seconds, for which 5 conditions are checked, it is not 
 so much an impact on performance, considering that we are processing
 an audio packet every 20 ms.

You rely too heavily on polymorphism and RTTI - one dynamic_cast for 
each condition of each transition is way too heavy!
 Sure, but as noted above, there should not be heavy processing done
 in the DSM. If you need this, then consider writing your app entirely 
 in C++.

SEMS has a dynamically typed type (AmArg), why not use that one for 
variables? That would also make DI simpler. 
 a patch is very welcome, best to semsdev list: semsdev@iptel.org or 
 the tracker: http://tracker.iptel.org.
 There is also the avar array ("AmArg-Var"), which can hold AmArg 
 variables.

some performance numbers? 
 unfortunately not yet for running DSMs. DSM processing is actually fast: 
 a (quite simple) 3 state 5 transition DSM compiles in 0.2ms on P-M 2GHz.
 So the diagram could actually be read when the call is setup, or DSMs could
 load other DSMs (e.g. loadFSM() action)
</pre></div>  <h2><a class="anchor" id="dsm_syntax"></a>
DSM Syntax</h2>
<div class="fragment"><pre class="fragment">DSM quick reference
===================

Syntax
======
-- comment
# also comment

#include "script.dsm"
#include "/path/to/anotherscript.dsm"
import(mod_name);

[initial] state name 
	  [ enter { 
	     &lt;actions&gt;
	    } ] 
	  [ exit {
	     &lt;actions&gt;
	    } ]
      ;

transition name s1 - [ { [not] condition; [not] condition; ... } ] [/ { &lt;actions&gt;} ]  -&gt; s2;
 or 
transition name (s1a, s1b[, s1c, ...])  - [ { [not] condition; [not] condition; ... } ] [/ { &lt;actions&gt; } ]  -&gt; s2;
 or (exception transition)
transition name s1 - exception [ { [not] condition;  ... } ] [/ { &lt;actions&gt;} ]  -&gt; s2;


function func_name() {
  &lt;actions&gt;
};

&lt;actions&gt; ::=
  action;
  action(param, param, ...);

  if condition; condition; {
   &lt;actions&gt;
  } else {
   &lt;actions&gt;
  }

  func_name();
  ...


Variables, event parameters, selects
====================================

#paramname uses the event parameter 'paramname' (from current event)
$varname uses the variable varname (from session's variable)
@selectname uses the "select" 'selectname' (from the session's dialog)

 use ## for #  (e.g. set($hash=##); )
     $$ for $  (e.g. set($dol=$$); )
     @@ for @  (e.g. set($at=@@); )

Variable arrays:
 $myarray[0]
 $myarray[1]
 ...

Variable structs:
 $mystruct.member1
 $mystruct.member2

Core actions
============

DSM flow
--------


 -- call/jump/return sub-FSM
 jumpFSM(name)
 callFSM(name)   - note that actions after callFSM may have the event &amp; event params of the sub-FSM  
 returnFSM()

 stop(&lt;send bye&gt;)
   e.g. stop(false), stop(true)

 -- reprocess the current event after transition:
 repost()

 Variable manipulation
 ---------------------

 set($var=value)
  e.g.  set($var="text"); set($var=$var2); set($var=#key)
 sets($var=value)
  e.g.  sets($var="text and some $variable and some #param");
        sets($var="$(variable1)$(variable2)");
        sets($var="this is a single hash: ##")
        sets($var="a single at on a date with a single dollar: @@$$")
 var($dstvar=srcvarname)
  e.g.  var($dstvar=$var_counter)
 param($dstvar=srcparamname)
  e.g. param($dstvar=$myparam) (like: #($myparam) )
 eval($var=value) 
  evaluate expression (only simple binary + and - supported)
  e.g.  set($var=1+5); set($var=$var2); set($var=#key)
 append($var, value)
 e.g. append($var, "text"); append($var, #key);
      append($var, @select); append($var, $var2);
 substr($var, pos)
  e.g. substr($myvar, 5);
 
 size($arrayname, $dst);
  set variable $dst to size of array 
  (e.g. $arrayname[0], $arrayname[1] set, $dst set to 2)

 arrayIndex($array, key)  - find key in $array, set $index to its index, or "nil" if not found
 arrayIndex($array, $var) - find $var in $array, set $var.index to its index, or "nil" if not found

 inc($var)
 clear($var)
 clearStruct($var)
  clears all var.* variables
 clearArray($var)
  clears all var[* variables 

 
Playing prompts and file I/O
----------------------------

  playPrompt(param)
   from promptCollection, e.g. playPrompt("hello");
   if $prompts.default_fallback=yes, default prompt set is tried if
   prompt not found in current prompt set
   Throws "prompt" exeption with #name if prompt not found.
 playPromptFront(param) - play a prompt at first item in the playlist
 playPromptLooped(param)

 setPromptSet(name)
   select active prompt set if more prompt sets are loaded
   Throws "prompt" exeption with #name if prompt set not found

 playFile(filename [, loop=true])
   e.g. playFile($myfile, true); will play the file looped.
   Throws "file" exeption with #path if file can not be opened

 playFileFront(filename [, loop=true])
   e.g. playFileFront($myfile, true); will play the file at first
   position in the playlist, and looped.
   Throws "file" exeption with #path if file can not be opened

 playSilence(millisec)      - play silence for millisec ms
 playSilenceFront(millisec) - play silence for millisec ms at first position in playlist

 playRingtone(varname, bool front) - play ringtone - parameters in varname
 e.g. set($r.length=10000);
      set($r.on=150);
      set($r.off=550);
      set($r.f=550);
      set($r.f2=850);
      playRingtone($r,true);

 recordFile(filename)
   Throws "file" exeption with #path if file can not be opened for recording

 stopRecord()
 getRecordLength([dst_varname])   -- only while recording! default dst var: record_length
 getRecordDataSize([dst_varname]) -- only while recording! default dst var: record_data_size
 flushPlaylist()
 setInOutPlaylist() 
   set playlist as input and output
 setInputPlaylist() 
   set playlist as input (output untouched)
 setOutputPlaylist() 
   set playlist as output (input untouched)
 addSeparator(id [, bool front])
   fires event when playlist hits it ; front=[true|false]
 connectMedia()     - set playlist as input and output of session,
                      and start processing of RTP and audio 
                     (connect to mediaprocessor)
 disconnectMedia()  - stop processing of RTP and audio (disconnect from mediaprocessor)

 enableReceiving()  - enable processing of received RTP
 disableReceiving() - disable processing of received RTP

 enableForceDTMFReceiving()  - enable/disable RTP DTMF packets processing even 
 disableForceDTMFReceiving()   if received RTP is not processed, e.g. after
                               disableReceiving() or in passive mode
                               (only for RFC2833/4733 DTMF, *no* in-band)
 monitorRTPTimeout(enabled=false)
   set call to monitor RTP timeout (enabled="true" or "false")

 mute()             - set RTP stream to muted (don't send RTP packets)
 unmute()           - set RTP stream to unmuted (do send RTP packets)

DTMF
----

 enableDTMFDetection() 
 disableDTMFDetection()

sendDTMF(key [, duration_ms])
  send a DTMF event (RFC4733 event)
  duration_ms defaults to 500ms

sendDTMFSequence(sequence [, duration_ms])
  send a sequence of DTMF events (RFC4733 event), e.g. 123#45*1
  duration_ms defaults to 500ms

B2B call control
----------------
 B2B.connectCallee(remote_party, remote_uri)
   connect second leg of B2B session (see AmB2BSession)
    R-URI = remote_uri
    To = remote_party 
    From = $b2b_local_party
    auth = ($b2b_auth_user, $b2b_auth_pwd)
    Call-ID = $b2b_callid
    $b2b_relayed_invite=[true|false] : use relayed INVITE mode

 B2B.terminateOtherLeg
   disconnect second leg of B2B session (see AmB2BSession),
   e.g. to connect to a new destination
   note: don't use this when receiving BYE in an established
         B2BUA call, as the BYE is sent end-to-end

 B2B.sendReinvite(generate_sdp [, string extra_headers])
   send a reinvite in caller leg (first leg), e.g. to 
   reconnect first leg after B2B.otherBye received. 
   generate_sdp can be 'true' or 'false'
   (B2B.sendReinvite(true) recommended)

 B2B.clearHeaders()
   clear the headers used for outgoing INVITE on B leg

 B2B.enableEarlyMediaRelay(enable=[true|false])
   enable or disable relaying of early media SDP (180-183) as re-Invite in the first leg

 B2B.addHeader(string header)
  add a header for outgoing INVITE on B leg
 
 B2B.removeHeader(string header_name)
  remove a header for outgoing INVITE on B leg
 
 B2B.setHeaders(string headers [, replace_crlf=true|false])
  set headers for outgoing INVITE on B leg
  replace_crlf=true for replacing \r\n with CRLF
  e.g. 
  B2B.setHeaders("P-One: value\r\nP-Two: anothervalue", true)

 B2B.relayEvent(variable_name;variable_name;...)
   relay B2Bevent to related B2B session; variables copied as event parameters
   e.g. B2B.relayEvent(var1;var2;var3)     relay event with var1, var2, var3

 B2B.relayEvent("var")
   relay B2Bevent to related B2B session with all variables of current DSM session

 Logging
 -------

 log(level, text)
   e.g. log(1, $var1)
 logs(level, "text with $(variable_name) and #(paramname) replacements")
 -- log all variables:
 logVars(level) 
 -- log all selects:
 logSelects(level) 
 -- log all Params (only in actions of a transition):
 logParams(level) 
 -- log everything:
 logAll(level)
 dbg("some debug with $(replaced_var)") 
 info("some info $(message)")
 warn("warn #(message_parameter)")
 error("error in call @(local_tag)")

 Timers
 ------

 setTimer(timer_id, timeout)
   e.g. setTimer(1, $timeout)
   * sets $errno (arg,config)
 removeTimer(timer_id)
   * sets $errno (arg,config)
 removeTimers()
   * sets $errno (config)

 DI functions
 ------------
  DI(factory, function [, params...])
    execute DI function
    e.g. DI(factory, function, $var_param, (int)int_param, "str param", @select_par, (array)arrayname, (struct)structname, (json)json_object...)
       DI(monitoring, set, "mytable", @local_tag, (int)1);

       set($sweets.candy="nice");
       set($sweets.fruit="superb");
       set($sweets.cake.tahini="great");
       DI(myfactory, myfunc, (struct)sweets);

       set($bi[0]="ba");
       set($bi[1]="butzki");
       DI(myfactory, myfunc, (array)bi);
        
       set($js="{"x":"y", "a": 1}");
       DI(myfactory, myfunc, (json)$js);

   * sets $errno (arg,config)

  DIgetResult(factory, function, param,...)
    saves result from DI call to DI_res or DI_res0, DI_res1, ...
   * sets $errno (arg,config)

  Exception handling
  ------------------
  throw(&lt;type&gt;[,arg1=val1;arg2=val2;...])
   e.g. throw(bad_command),  throw(bad_command,cmd=help;reason=whynot)

  throwOnError()

 Events
 ------
 postEvent(sess_id[, variable_name;variable_name;...])
   post dsm event to session sess_id; variables copied as event parameters
   e.g. postEvent(@local_tag, PAI) : post event to ourselves
        postEvent($some_call, var1;var2;var3)     post event with var1, var2, var3
   * sets $errno (arg)

 postEvent(sess_id, var)
   all local variables copied as event variables
   * sets $errno (arg)

  registerEventQueue(queue_name)
    register session to receive events under the name queue_name
    WARNING: make sure to unregister the event queue before ending the session!

  unregisterEventQueue(queue_name)
    unregister events queue queue_name

 Object memory management/Garbage collector:
  freeObject(varname)     - free object referenced with varname immediately
  trackObject(varname)    - track object referenced with varname, i.e. enable garbage
                            collection with the current call/systemDSM
  releaseObject(varname)  - release object referenced with varname from garbage collector
  
Conditions
==========
 
Conditions are combined as AND, i.e. a transition is executed if all conditions match.

Generic conditions (regardless of the type of the event):
 test(#key == 1)
 test(#key == prefix*)
 test(#key != 1)
 test(#key &lt; 1)
 test(#key &gt; 1)

 test($var == 1)
 test($var == prefix*)
 test($var != 1)
 test($var &lt; 1)
 test($var &lt; 1)

 test(len($var) &lt; len(#key))
 test(len($var) &lt; len(@user))

Other conditions only match on the type of event and when the expression expr in the
brackets match.

 start
   start of a session (onStart). This event is processed before any other.

beforeDestroy
   end of a session (onBeforeDestroy). This event is processed after any other.

 hangup
   bye/cancel received
   parameters:
      #headers - headers of the BYE/CANCEL request

 key(expr) or keyTest(expr)
   parameters:
      #key - Key pressed (0 - 11, * is 10, # is 11)
      #duration - duration of key press

 timer(expr) or timerTest(expr)
   parameters:
      #id - Timer ID

 noAudio(expr) or noAudioTest(expr)
   parameters:
      #type - "cleared" (audio cleared) or "noAudio" (playlist empty)

 separator(expr) or separatorTest(expr)
   parameters:
      #id - Separator ID
   e.g. separatorTest(#id == 5)

 event(expr) or eventTest(expr)
  generic event, e.g. passed from DI or another call with postEvent
  parameters depend on the DI call/the ones passed with postEvent

B2Bevent(expr)
  generic event from B2B related call leg
  parameters depend on the ones passed with B2B.relayEvent

 keyPress(key)
  alias to key(#key==key)

 remoteDisappeared(expr)
   remote end in an established call is unreachable (408/481 received)
   parameters: see sipReply (below), except #old_dlg_status

   set #processed="true" if you don't want default behaviour (clear call)

 sessionTimeout(expr)
   session expired (SST)
   parameters: none

   set #processed="true" if you don't want default behaviour (clear call)

 rtpTimeout(expr)
   RTP timeout detected

   #type           - "rtp_timeout"
   #timeout_value  - RTP timeout value (as configured)

   set #processed="true" if you don't want default behaviour (clear call)

 invite
   invite received/sent (only with run_invite_event):
   parameters: none

 ringing
   outgoing call: ringing reply, 180 (only with run_invite_event):
   parameters:
      #code     - SIP response code, e.g. 180
      #reason   - SIP reason string, e.g. "Ringing"
      #has_body - "true" or "false" 

 early
   outgoing call: early session, 183 (only with run_invite_event):
   parameters: none

 failed
   outgoing call failed (only with run_invite_event):
   parameters:
      #code     - SIP response code, e.g. 404
      #reason   - SIP reason string, e.g. "Not found"

 sessionStart
   start of session (with run_invite_event):
   parameters: none

 startup
   startup of a system DSM
   parameters: none

 reload
   reload (system DSM)

 system
   system event - shutdown or SIGNAL sent (kill &lt;pid&gt;)
   parameters:
      #type     - system event type, e.g. ServerShutdown, User1, User2

 B2B.otherRequest (only sbc)
   Request on other B2B leg received
   parameters:
    #method, #r_uri, #from, #to, #hdrs  - from request

 B2B.otherReply
   Reply on other B2B leg received
   parameters:
    #code    - reply code
    #reason  - reply reason
    #hdrs    - headers
    #trans_method - transaction method (only sbc)
     
 B2B.otherBye
   BYE on other leg received
    #hdrs    - headers

 sipRequest
   SIP request received - only executed if enable_request_events=="true"
   parameters:
    #method        - SIP method
    #r_uri         - request URI
    #from          - From
    #to            - To
    #hdrs          - Headers (apart from dialog-IDs)
    #content_type  - Content-Type
    #body          - body of message
    #cseq          - CSeq

 sipReply
   SIP reply received - only executed if enable_reply_events=="true"
   parameters:
    #code          - response code
    #reason        - reason string
    #hdrs          - Headers (apart from dialog-IDs)
    #content_type  - Content-Type
    #body          - body of message
    #cseq          - CSeq

    #dlg_status     - SIP dialog status (Disconnected, Trying, ...)
    #old_dlg_status - old SIP dialog status (before this reply)


 jsonRpcRequest - json-rpc request received
   parameters:
   #ev_type   - JsonRpcRequest
   #method    - RPC method
   #is_notify - "true" or "false"
   #id        - request ID (if present)

   #params.*  - parameters array

subscription - SIP subscription status
   #status   - status: "active", "pending", "failed", "terminated", "timeout"
   #code     - SIP response code (if failed)
   #reason   - SIP response reason (if failed)
   NOTIFY body in avar[DSM_AVAR_SIPSUBSCRIPTION_BODY] (if #status=="active")

 jsonRpcResponse - json-rpc response received
   #ev_type  - JsonRpcResponse
   #id       - response ID
   #is_error - "true" or "false"
   #udata    - user data that was saved when sending the request

   #result.* or #error.* - response data array (or error data)

conference events:
  generic events with 
   #type     - "conference_event"
   #id       - event ID

Selects
=======
selects :
 @local_tag
 @user
 @domain
 @remote_tag
 @callid
 @local_party
 @local_uri
 @remote_uri
 @remote_party

Importing modules
=================

 module imported with import(mod_name); loads mod_name.so in 
 module load path. modules provide conditions and actions.
 modules' actions/conditions-factory is checked first 
 (modules can override core conditions/actions)

Variables controlling call flow
===============================
special variables:
    connect_session     "0" -&gt; after the start event (initial transition):
                                  do not connect session to 
                                  media processor on start

                            -&gt; after the invite event:
                                  do not reply with 200 OK and do not 
                                  connect session to media processor on start
   enable_request_events  "true"  - run events on receiving a request
                          "false" - don't run events on receiveing request 


   b2b_local_party                - From in outgoing B2B call
   b2b_local_uri                  - URI of From for B2B call, for application internal use
   b2b_auth_user                  - SIP auth user for 2nd leg of B2B call  
   b2b_auth_pwd                   - SIP auth pwd for 2nd leg of B2B call
    
=============================
errors:
   actions set $errno
     #define DSM_ERRNO_OK          ""
     #define DSM_ERRNO_FILE        "1"
     #define DSM_ERRNO_UNKNOWN_ARG "2"
     #define DSM_ERRNO_GENERAL     "99"
     ...
</pre></div>  <h2><a class="anchor" id="dsm_errorhandling"></a>
Error handling in DSM</h2>
<div class="fragment"><pre class="fragment">Error handling in DSM
---------------------

There are two mechanisms of error handling in DSM: 
Reporting an error as $errno, and throwing an exception.

Some actions throw an exception directly if a severe error occurs, 
for example the "playFile" action if the file could 
not be opened. These functions are marked with 
 "   Throws "&lt;xyz&gt;" exeption with &lt;arguments&gt;  if ..."
in the description/documentation.

Other actions just set the error variable $errno. After those
the DSM script may execute the throwOnError(); action, which
throws an exception if the error is set. These actions are
marked in the description as "Sets Errno."

All actions that may set the variable $errno to some value
need to reset $errno if no error occured, otherwise an exception
from an error of a previous action could be thrown.

Exceptions may be caught with exception transitions (see general DSM 
description). 

For Python (mod_py), exception handling is special - the the mod_py
documentation.


Example 1: Handling file exceptions
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
state BEGIN 
enter {
  playFile(maybeexisting.wav);
};
transition "key pressed" BEGIN - keyPress(1) -&gt; OTHER;

state OTHER
enter {
  playFile(mayalsobeexisting.wav);
};

transition "file error" (BEGIN, OTHER) - exception; test(#type=="file") /
 stop(true) -&gt; end;
transition "hangs up" (BEGIN, OTHER) - hangup / stop(false) -&gt; end;

state end;
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-


Example 2: Handling error with exception
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-
import(mod_mysql);
state BEGIN 
enter {
  mysql.connect();
  throwOnError();
  mysql.queryGetResult(select file from prompts where user=@user);
  throwOnError();
  playFile($file);
};
transition "mysql connection error occured" BEGIN - exception; test(#type=="connection") /
   log(1, MySQL connection error); playFile(sorry_error.wav) -&gt; PLAYEND;

transition "mysql query error / no result" BEGIN - exception; test(#type=="noresult") /
   playFile(default_prompt.wav) -&gt; PLAYEND;

transition "file opening error" BEGIN - exception; test(#type=="file") /
   playFile(default_prompt.wav) -&gt; PLAYEND;

transition "other error occured" BEGIN - exception;  /
  log(1, error:); log(1, #text); playFile(sorry_error.wav) -&gt; PLAYEND;

state PLAYEND;
transition "finished" PLAYEND - noAudioTest / stop(true) -&gt; end;
state end;
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-

</pre></div>  <h2><a class="anchor" id="dsm_todo"></a>
DSM Todo</h2>
<div class="fragment"><pre class="fragment">
 x run_invite_event per DSM script
 o explicit condition ordering (explicit priority)
 o checking of FSM consitency (e.g. target state names)
 o better error reporting in script compilation (e.g. line number)
 x better error handling (exceptions)
 x 'not' operator on conditions
 o 'or' operator
 x provide session init function for modules
 x embed python interpreter in module ?
   -&gt; py( ... python code ... ) condition and action
 x correct en/decode DI args (e.g. arrays)
 o replace DSMSession::map&lt;string, string&gt; var with map&lt;string, AmArg&gt;
   var -&gt; avar
 x register scripts as app  
 x mod_mysql 
 o session creation from module
</pre></div> <h2><a class="anchor" id="dsm_mods"></a>
DSM modules</h2>
<h3><a class="anchor" id="dsm_mod_sys"></a>
mod_sys - System  functions</h3>
<div class="fragment"><pre class="fragment">Actions: 
 sys.mkdir(string dirname)
 sys.mkdirRecursive(string dirname)
 sys.rename(string from, string to)
 sys.unlink(string filename)
 sys.unlinkArray(string filename, string prefix)
    Array version of unlink (prefix/filename_0 .. prefix/filename_$filename_size) 
 sys.tmpnam(string varname)

 sys.popen($var="command")
   execute a command (using popen) and save result in $var
   example:
     sys.popen($myfiles="/bin/ls wav/*");
   throws exceptions
    #type=="popen", #cause==reason if fails to exec
    #type=="pclose", #cause==reason if fails to close pipe
 
 sys.getTimestamp(string varname) - get timestamp in varname.tv_sec/varname.tv_usec
 sys.subTimestamp(ts1, ts2)  - subtract $ts2 from $ts1, save result in
                               $ts1.sec, $ts1.msec and $ts1.usec

Conditions: 
 sys.file_exists(string fname)
 sys.file_not_exists(string fname)


</pre></div> <h3><a class="anchor" id="dsm_mod_dlg"></a>
mod_dlg - Dialog related functionality</h3>
<div class="fragment"><pre class="fragment">* mod_dlg saves the initial INVITE to DSMSession::last_req,
  this can be processed with dlg.reply(...)/dlg.acceptInvite(...)
* set connect_session to 0 with set(connect_session=0)
  if you want to reply with other than the standard 200 OK 
  to initial INVITE received.
* for processing of other requests, use set($enable_request_events="true") and replyRequest
* for processing of other requests, use set($enable_reply_events="true") and replyRequest

* Request/Reply body handling with 
 dlg.requestHasContentType condition and dlg.getRequestBody action
 dlg.replyHasContentType condition and dlg.getReplyBody action

dlg.reply(code,reason);
 reply to the request in DSMSession::last_req 
 (usually INVITE, if not yet replied) with code and reason
 * sets $errno (arg,general)

dlg.replyRequest(code,reason);
 request processing in script; use with set($enable_request_events="true");
 reply to any request (in avar[DSM_AVAR_REQUEST]) with code and reason

 headers can be added by setting $dlg.reply.hdrs, e.g.
    set($dlg.reply.hdrs="P-Prompt-Type: Charging-info\\r\\nP-Prompt-Content: 5\\r\\n");
    dlg.acceptInvite(183, "progress");

 * sets $errno (arg,general)
 * throws exception if request not found (i.e. called from other event than
   sipRequest)

dlg.acceptInvite([code, reason]);
 e.g. dlg.acceptInvite(183, progress);
  headers can be added by setting $dlg.reply.hdrs, e.g.
    set($dlg.reply.hdrs="P-Prompt-Type: Charging-info\r\nP-Prompt-Content: 5\r\n");
    dlg.acceptInvite(183, "progress");
 * sets $errno (arg,general)
 
 accept audio stream from last_req (INVITE), and reply with 200 OK (default)
 or code, reason. sets "dlg" type errno if negotiation fails.
 
dlg.bye([headers])
 send BYE. useful for example for continuing processing after call has ended.
 * sets $errno (general)

dlg.connectCalleeRelayed(string remote_party, string remote_uri)
 like B2B.connectCallee() but for relayed INVITEs, i.e. for executing in 
 invite run (run_invite_event=yes and transition "on INVITE" START - invite -&gt; runinvite;)


dlg.dialout(string arrayname)
  dial out a new call
  simple format/mandatory:
   arrayname_caller   caller user
   arrayname_callee   callee user
   arrayname_domain   domain caller and callee
   arrayname_app      application to execute

  additional/overwrite:
   arrayname_r_uri     INVITE request URI
   arrayname_from      From
   arrayname_from_uri  From URI (only internally used)
   arrayname_to        To
   arrayname_auth_user authentication user
   arrayname_auth_pwd  authentication pwd
   arrayname_ltag      ltag for new call - must be new
   arrayname_hdrs      headers for new call

   arrayname_var.*     variables for new call, e.g.
                       arrayname_var.somevar will be set as $somevar

  returns $arrayname_ltag (if successful) and sets ERRNO.

   
dlg.getOtherId(varname)
   get other related dlg id in $varname

dlg.getRtpRelayMode(varname)
   get RTP relay mode (RTP_Direct, RTP_Relay, RTP_Transcoding) in $varname

dlg.refer(string refer_to [, int expires=0])
   refer to refer_to, optionally with expires

dlg.info(content_type, body)
   send INFO request; use \r\n for crlf in body

dlg.relayError(code,reason);  -  relay reply (&gt;=200) to B2B request (sbc)
  reply to B2B request (in avar[DSM_AVAR_REQUEST]) with code and reason
  sbc: set(#StopProcessing="true") to prevent B2B request to be relayed
       after replying from DSM script

Request/Reply Body handling in sipRequest/sipReply events:
----------------------------------------------------------
actions (applicable only in sipRequest/sipReply event handling blocks):
dlg.getRequestBody(content_type, dstvar)  - get body of content_type in $dstvar
dlg.getReplyBody(content_type, dstvar)    - get body of content_type in $dstvar
dlg.addReplyBodyPart(content_type, payload) - add new body part possibly
  converting the resulting body to multipart
dlg.deleteReplyBodyPart(content_type) - delete body part from multipart
  body possibly converting the resulting body to singlepart

conditions: 
  dlg.replyHasContentType(content_type) and dlg.requestHasContentType(content_type)

  checks whether request/reply has a certain content type

 example: 

transition "msg recvd" A - sipRequest; dlg.requestHasContentType(application/ISUP) / {
  dlg.getRequestBody(application/ISUP, isup_body);
  ... do sth with $isup_body ...
} -&gt; B;
</pre></div> <h3><a class="anchor" id="dsm_mod_uri"></a>
mod_uri - URI parser and related functionality</h3>
<div class="fragment"><pre class="fragment">uri.parse(&lt;uri&gt;, &lt;prefix&gt;)
  splits &lt;uri&gt; in 
    &lt;prefix&gt;display_name
    &lt;prefix&gt;user
    &lt;prefix&gt;host
    &lt;prefix&gt;port
    &lt;prefix&gt;headers
    &lt;prefix&gt;param

   example: 
    uri.parse(@remote_uri, remote_);
    uri.parse($PAI, pai_);

  * Sets $errno (general).

uri.parseNameaddr(&lt;nameaddr&gt;, &lt;prefix&gt;)
  splits &lt;nameaddr&gt; in 
    &lt;prefix&gt;display_name
    &lt;prefix&gt;user
    &lt;prefix&gt;host
    &lt;prefix&gt;port
    &lt;prefix&gt;headers
    &lt;prefix&gt;param

    &lt;prefix&gt;uri_param.&lt;name&gt; [= value]

   example: 
    uri.parseNameaddr(@remote_party, remote_);

  * Sets $errno (general).

uri.getHeader(&lt;header&gt;, &lt;dst&gt;)
    get header from initial INVITE into variable &lt;dst&gt;

    example:
    	uri.getHeader(P-Asserted-Identity, PAI);

 
uri.encode($dstvar=text)  - encode special characters into dstvar
   e.g. uri.encode($replaces_hdr=$replaces_hdr);

uri.decode($dstvar=text)  - decode special characters into dstvar
   e.g. uri.encode($replaces=$replaces_hdr);
</pre></div> <h3><a class="anchor" id="dsm_mod_utils"></a>
mod_utils - Utility functions</h3>
<div class="fragment"><pre class="fragment">Actions: 
 utils.getNewId(string varname)

 utils.playCountRight(int cnt [, string basedir])
    play count for laguages that have single digits after the 10s (like english)
    * Throws "file" exeption with #path if file can not be opened
    * sets $errno (arg)

 utils.playCountLeft(int cnt [, string basedir])
    play count for laguages that have single digits before the 10s (like german)  
    * Throws "file" exeption with #path if file can not be opened
    * sets $errno (arg)

 utils.getCountRight(int cnt [, string basedir])
    get filenames for a number for laguages that have single digits after the 10s (like english)
    into count_file[n]  (i.e. count_file[0] .. count_file[n])
    * sets $errno (arg)

 utils.getCountLeft(int cnt [, string basedir])
    get filenames for a number for laguages that have single digits before the 10s (like german)  
    into count_file[n]  (i.e. count_file[0] .. count_file[n])
    * sets $errno (arg)

 utils.getCountRightNoSuffix(int cnt [, string basedir])
 utils.getCountLeftNoSuffix(int cnt [, string basedir])
    as above but without .wav suffix

 utils.spell(string word[, string basedir])
  plays each character in the word (e.g. utils.spell(321,wav/digits/) plays
    wav/digits/3.wav, wav/digits/2.wav, wav/digits/1.wav 
  (like SayDigits from *)
  * Throws "file" exeption with #path if file can not be opened

 utils.rand(string varname [, int modulo])
  generates random number: $varname=rand()%modulo or $varname = rand()

 utils.srand() 
  seed the RNG with time().

 utils.add($var, val)
   add val (float value) to var. also 
   utils.add($var1, $val); utils.add($var, #param)

 utils.sub($var, val)
   subtract val from var

 utils.int($var, val)
   get integer part of val into var

 utils.splitStringCR($var [, $dstvar])
 utils.splitStringCR(val, $dstvar])
   split a string on newline (carriage return, \n) 
   into an array ($var[0]..$var[n])

   example: 
    sys.popen($myresult="/bin/ls wav/*");    
    utils.splitStringCR($myresult);

 utils.escapeCRLF($var)
   replace CRLF (\r\n) in string with escaped CRLF (\\r\\n) 

 utils.unescapeCRLF($var)
   replace escaped CRLF (\\r\\n) in string with CRLF (\r\n) 


utils.playRingTone(length [, on [, off [, f [, f2]]]])
   play a RingTone (ringback tone)
   defaults to length=0 (indefinite), on 1000ms, off 2000ms, f 440Hz, f2 480Hz

   Example:
      utils.playRingTone(0, 1000, 4000, 425, 0);   -- Germany

Conditions
----------

utils.isInList(key, cs_list) - match if key is in comma-separated list
   e.g. if utils.isInList(#sip_code, "404, 405") { ... }
</pre></div> <h3><a class="anchor" id="dsm_mod_monitoring"></a>
mod_monitoring - Monitoring functions</h3>
<div class="fragment"><pre class="fragment">Actions: 

actions that work on the log entry for the call 
-----------------------------------------------

monitoring.set(string property, string value) - set one property
monitoring.log - alias to monitoring.set(...)

monitoring.add(string property, string value) - add a value to a property
monitoring.logAdd - alias to monitoring.add(...)


monitoring.logVars()
  adds all variables to log (might be a lot!)

actions that work on the global log
-----------------------------------

monitoring.setGlobal(id, name, value) - set one property to table 'id'
monitoring.addGlobal(id, name, value) - add one value to property in
                                        table 'id'
</pre></div> <h3><a class="anchor" id="dsm_mod_conference"></a>
mod_conference - Conferencing functions</h3>
<div class="fragment"><pre class="fragment">Actions: 
 conference.join(string roomname [, string mode])
   mode = "" | speakonly | listenonly
   Throws "conference" Exception if conference can not be joined (currently never).

 conference.leave()
   destroy conference channel. Flush playlist with flushPlaylist() first!!!!!
   * Sets $errno (script).

 conference.rejoin(string roomname [, string mode])
   mode = "" | speakonly | listenonly
   Throws "conference" Exception if conference can not be joined (currently never).

 conference.postEvent(string roomname, int event_id)
   * Sets $errno (arg).

 conference.setPlayoutType(string type)
   where type is one of ["adaptive", "jb", "simple"]

conference.teejoin(string roomname [, string avar_id])
   - speak also to conference with roomname
   - avar_id is the name in which conference channel is stored 
   - if this is called in the beginning of a call (sessionStart event, 
     or initial state enter block), call setInOutPlaylist before 
     conference.teejoin (teejoin uses input to connect to audio queue,
     which is normally set only after running sessionStart event in 
     inital state)

conference.teeleave([string avar_id])
   - leave tee conference (release conf channel)
   - resets playlist as input and output

conference.setupMixIn(float level, unsigned int seconds)
   - set up MixIn for mixing in files into output later
    notes: 
      o only do that when playlist is input/output 
          (possibly do setInOutPlaylist first)
      o in sessionStart event, set $connect_session=0, otherwise
        playlist will be set as output again, and MixIn does not 
        play, e.g.
          set($connect_session=0);
          setInOutPlaylist();
          conference.setupMixIn(0.5);

     o if you use setupMixIn multiple times, use setInOutPlaylist first!!!!!
       otherwise it could crash if old MixIn is still in the output / 
       the audio queue

conference.playMixIn(string filename)
    - mix in a file

conference.playMixInList(string filename [, loop=true])
    - add a file to the mix-in playlist
    - the list is setup when this is called for the first time and set as mixin source 

conference.flushMixInList()
    - flush mix-in playlist
</pre></div> <h3><a class="anchor" id="dsm_mod_mysql"></a>
mod_mysql - MySQL DB access</h3>
<div class="fragment"><pre class="fragment">mod_mysql - Copyright (C) 2009 TelTech Systems Inc.

configuration
=============

DB connection can be configured in dsm.conf: 
$config.db_url : mysql://user:pwd@host/db

Actions:
=======
-- connect connection
 
 mysql.connect([db_url])
  - sets $errno if error occured (arg,) and
   $db.ereason
   $db.errno if available


-- disconnect connection
 mysql.disconnect()
  - sets $errno if error occured and
   $db.ereason

-- execute query 

 mysql.execute(INSERT INTO mytable (username,pin) values ($username, $pin));

 * query string has replacement for vars and params, \$=$, \#=#
 * sets 
    $errno
    $db.rows
    $db.info
    $db.insert_id

 
-- execute query and store result
 mysql.query(SELECT * FROM mytable);

 * query string has replacement for vars and params, \$=$, \#=#
    mysql.query(SELECT * FROM mytable where user=$username);
    mysql.query(SELECT * FROM mytable where key=#key);

 * sets 
    $errno
    $db.rows

-- execute query and get first or nth result row
 mysql.queryGetResult(SELECT * FROM mytable [, row]);

 * query string has replacement for vars and params, \$=$, \#=#
    mysql.query(SELECT * FROM mytable where user=$username);
    mysql.query(SELECT * FROM mytable where key=#key);

 * sets 
    $errno
    $db.rows

-- resolve query parameters (as it would do on mysql.execute, mysql.query etc)
   mysql.resolveQueryParams(str)

 * query string has replacement for vars and params, \$=$, \#=#
    mysql.resolveQueryParams(SELECT * FROM mytable where user=$username);

 * sets 
    $db.qstr

-- get result in $var
 mysql.getResult([rowindex[, colname]])

 get first result row in $vars, if any
   mysql.getResult()

 get nth result row
   mysql.getResult(2) 

 get nth result row, only named column
   mysql.getResult(2, colname)

-- gets client version into $db.client_version
 mysql.getClientVersion()

-- save result into another name
  mysql.saveResult(string name)

-- use saved result
  mysql.useResult(string name)

-- play a file from DB 
  mysql.playDBAudio(string query, string filename)

  filename is there to detect file type

-- play a file from DB, looped 
  mysql.playDBAudioLooped(string query, string filename)

  filename is there to detect file type

-- play a file from DB, at the front in the playlist 
  mysql.playDBAudioFront(string query, string filename)

  filename is there to detect file type

-- get a file from DB to local fs
  mysql.getFileFromDB(string query, string filename)

-- put a local file into DB
  mysql.putFileToDB(string query, string filename)

  __FILE__ in query is replaced with the contents of the file at 'filename'

  sets $db.rows, $db.info, $db.insert_id

 -- escape:
 mysql.escape($dstvar=$src);

  save SQL-escaped version of $src in $dstvar, taking into account default
  character set of connected DB server. A connection to MySQL server must be
  established!

  examples:
     mysql.escape($safe_user=@user);


Conditions
==========
  mysql.hasResult()

  mysql.connected()

ERROR codes 
===========
$errno:

#define DSM_ERRNO_MY_CONNECTION "connection"
#define DSM_ERRNO_MY_QUERY      "query"
#define DSM_ERRNO_MY_NORESULT   "result"
#define DSM_ERRNO_MY_NOROW      "result"
#define DSM_ERRNO_MY_NOCOLUMN   "result"

Internals
=========
mysql++ objects are saved to AmArg objects, and ownership is transferred
to the session:

 MySQL++DB objects   saved to 
 ------------------+----------------
  Connection       | avar["db.con"]
                   | 
  Result           | avar["db.res"]
                   | 
  Result           | avar[parameter] on mysql.saveResult

Note: Due to the implementation of MySQL++, the complete result set has 
to be copied one more time internally, if mysql.query() is used. So if
only the first (or only) row is of interest, use mysql.queryGetResult() 


</pre></div> <h3><a class="anchor" id="dsm_mod_py"></a>
mod_py - Embedded Python functions</h3>
<div class="fragment"><pre class="fragment">mod_py - DSM actions and conditions in Python
=============================================

mod_py adds one action and one condition to DSM: py(...)

py() action may execute arbitrary python code; py() condition 
python code needs to evaluate to an expression which returns
True or False (or and int value).

The 'type' and 'params' are accessible to determine the current
event's type and parameters.

py() actions and conditions can access session's variables using
session.var(name) and session.setvar(name, value). Locals stay 
across different py(...) actions/conditions.

They may even directly use some media functionality implemented 
in DSM sessions - see session module's help below. But, 
conceptionally, mod_py is above DSM, so while it would be 
possible it is not recommended to extend it with functions that
manipulate the AmSession directly.

Indentation is a little ugly with multi-line py() actions. 
But this is Python's fault (in 21st century, who creates a 
programming language with fixed indentation?).

mod_py MUST be preloaded, to initialize the python interpreter.
add preload=mod_py to dsm.conf. 


locals
======
type    - event type (dsm.Timer, dsm.Key, ...)
params  - dictionary with event parameters 
           (e.g. params['id'] for event==dsm.Timer)
dsm     - module to access dsm functions (see below)
session - module to access session functions (see below)

exceptions
==========
dsm.playPrompt, dsm.playFile, dsm.recordFile and dsm.setPromptSet
may throw an exception. This is a Python RuntimeError exception,
not the DSM exception handling (exceptions in interpreted code
can not be catched through outside of the interpreter). 
The application needs to catch the exceptions in the python code
itself, and can then handle them or signal the DSM code to throw
an exception. example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
initial state begin 
 enter {
  py(dsm.INFO("hello dsm-world\n"))
  py(#
try:
	session.playFile('doesnotexist.wav')
except RuntimeError, e:
	dsm.ERROR('thats a runtime error: ' + e.message + '!\n')
	session.setvar('exception', e.message)
)
  log(2, huhu, still there);
  repost();
};
transition "catch py exception" begin - test($exception!="") / throw($exception) -&gt; begin;
transition "normal exception handling" begin - exception; test(#type=="file") -&gt; exception_state;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


example
=======
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import(mod_py);

initial state begin 
 enter {
  py(dsm.INFO("hello dsm-world"))
  py(#
session.setvar('some_variable','some val')
print session.var('some_variable')
print "dsm.Timer = ", dsm.Timer
)
  setTimer(1, 5);
  log(2, $some_variable)
  repost();
};

transition "timer" begin - py(type == dsm.Timer and params['id'] == '1')  / 
         py(session.playFile('wav/default_en.wav')); -&gt; wait;

transition "key 1" begin - py(type == dsm.Key and params['key'] == '1')  / 
         py(session.playFile('wav/default_en.wav')); -&gt; wait;

state wait;
transition "bye recvd" (begin, wait) - hangup / stop -&gt; end;
state end;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

modules
=======
------------------------
help on module session:

NAME
    session

FILE
    (built-in)

FUNCTIONS
    B2BconnectCallee(string remote_party, string remote_uri [, bool relayed_invite])
        connect callee of B2B leg

    B2BterminateOtherLeg()
        terminate other leg of B2B call

    addSeparator(string name[, bool front])
        add a named separator to playlist

    flushPlaylist()
        close the playlist

    connectMedia()
        connect media (RTP processing)

    disconnectMedia()
        disconnect media (RTP processing)

    getRecordDataSize()
        get the data size of the current recording

    getRecordLength()
        get the length of the current recording

    mute()
        mute RTP)

    playFile(string name [, bool loop[, bool front]])
        play a file

    playPrompt(string name [, bool loop])
        play a prompt

    recordFile(string name)
        start recording to a file

    select(string name)
        get a session's select

    setError(int errno)
        set error (errno)

    setPromptSet(string name)
        set prompt set

    setvar(string name, string value)
        set a session's variable

    stopRecord()
        stop the running recording

    unmute()
        unmute RTP

    var(string name)
        get a session's variable
------------------------------------
Help on module dsm:

NAME
    dsm

FILE
    (built-in)

FUNCTIONS
    DBG(string msg)
        Log a message using SEMS' logging system, level debug

    ERROR(string msg)
        Log a message using SEMS' logging system, level error

    INFO(string msg)
        Log a message using SEMS' logging system, level info

    WARN(string msg)
        Log a message using SEMS' logging system, level warning

    log(int level, string msg)
        Log a message using SEMS' logging system

DATA
    Any = 0
    B2BOtherBye = 13
    B2BOtherReply = 12
    DSMEvent = 10
    Hangup = 6
    Hold = 7
    Invite = 1
    Key = 3
    NoAudio = 5
    PlaylistSeparator = 11
    SessionStart = 2
    Timer = 4
    UnHold = 8
    XmlrpcResponse = 9



how to debug memory leak:
-------------------------

Unfortunately, it seems to be not simple to get embedded 
python interpreter leak free. Here is how to run with python's 
mem debug:

compile python with --with-pydebug, e.g. 

./configure --with-pydebug --prefix=/path/to/mod_dsm/python
make &amp;&amp; make install

set debug python in Makefile, e.g. replace PY_VER/PY_EXE:
 PY_VER = 2.5
 PY_EXE = ./python/bin/python

make mod_py with -D PYDSM_WITH_MEM_DEBUG

run sems with -E, make calls, end sems with ctrl-c
from python do scripts/combinerefs.py refs.txt.
generate calls with e.g. sipp:
sipp -sn uac -i 192.168.5.106 -s 35 -d 500 -r 400 192.168.5.106:5070
(sudo su; ulimit -n 100000  before starting sems)
</pre></div> <h3><a class="anchor" id="dsm_mod_aws"></a>
mod_aws - Amazon Web Services functions</h3>
<div class="fragment"><pre class="fragment">mod_aws - Copyright (C) 2009 TelTech Systems Inc.

This module brings Amazon Web Services to DSM. 

It uses and depends on libaws++, see http://aws.28msec.com/.

mod_aws must be preloaded. See aws.conf for configuration 
(aws credentials, connection pool size etc).

Actions
-------
S3: bucket name from $aws.s3.bucket is used if not specified as 
action parameter.

aws.s3.put(string filename [, string keyname]) 
  put file into bucket, if specified under key keyname, 
  else keyname=filename
  * throws Exception type="aws", with #cause
  * sets $errno (aws_put)


aws.s3.putArray(string filename_array [, string keyname_array])
  put files into bucket, if specified under key keyname, 
  else keyname=filename
  array is $filename_0, $filename_1, .. $filename_size
  * throws Exception type="aws", with #cause
  * sets $errno (aws_put,arg)

SQS: queue name from $aws.sqs.queue is used if not specified as 
action parameter.
 
aws.s3.createBucket([string bucket_name])
  create bucket. created bucket name in $aws.s3.bucket (should be same
  as bucket_name)
  * throws Exception type="aws", with #cause
  * sets $errno (aws_create,aws_conn,arg)

aws.sqs.createQueue(int visibilityTimeout [, string queue_name])
  create queue
  * sets $errno (aws_create,aws_conn,arg)

aws.sqs.deleteQueue([string queue_name])
  delete queue
  * sets $errno (aws_create,aws_conn,arg)

aws.sqs.sendMessage(string message [, string queue_name])
  send a message in queue. sets
    $aws.sqs.url
    $aws.sqs.md5
  * sets $errno (aws_create,aws_conn,arg)

Error handling
--------------
On error, errno is set, and aws.ereason has more detailed 
description.

Errno codes:
#define DSM_ERRNO_AWS_CONN    "50"
#define DSM_ERRNO_AWS_PUT     "51"
#define DSM_ERRNO_AWS_CREATE  "52"
#define DSM_ERRNO_AWS_DELETE  "53"
#define DSM_ERRNO_AWS_SEND    "54"
</pre></div> <h3><a class="anchor" id="dsm_mod_xml"></a>
mod_xml - XML utility functions</h3>
<div class="fragment"><pre class="fragment">mod_xml - generic XML functions

This module implements generic XML handling functions. XML objects are created in
objects, which must be tracked or released by the script using trackObject/freeObject.
Then functions can be executed on the XML objects, e.g. XPath evaluation.

mod_xml must be preloaded to initialize libxml2.

xml.parse("&lt;xml_obj/&gt;", dst_objname)
  parse XML string into object referenced with dst_objname.
  Example: xml.parse($myxml, xml_obj)

xml.parseSIPMsgBody(msg_body_object, dst_objname)
  Parse a SIP message body object into an XML object.
  Example: xml.parseSIPMsgBody("SipSubscriptionBody", "substatus")

xml.evalXPath(xpath_expr, xml_object)
  Evaluate XPath expression on XML object.
  Namespaces are registered in $xml_object.ns variable.
  The result is saved to xml_object.xpath object.
  Example: 
    set($substatus.ns="a=urn:ietf:params:xml:ns:reginfo")
    xml.evalXPath("//a:contact[@state='active']", "substatus");

xml.XPathResultCount($cntvar=xpath_object)
  Save result count of XPath result in xpath_object into counter variable $cntvar.
  Example:
    xml.XPathResultCount($rescnt="substatus.xpath");

xml.getXPathResult($dstvar=xpath_object)
  save contents of xpath result object into $dstvar,
  or $dstvar[0] .. $dstvar[n] if more than one result 

xml.printXPathResult($dstvar=xpath_object)
  print information abut XPath result into $dstvar (with object names)

xml.updateXPathResult(xpath_object=content) - update xpath object with content (xml string)
xml.updateXPathResult(xpath_object[index]=content) - update only object at position index

xml.docDump($varname=xml_object) - dump xml_object to variable $varname

xml.setLoglevel(level)
 set libxml2 error logging level. Default: error
 Valid: error, warn, info, debug
</pre></div> <h3><a class="anchor" id="dsm_mod_zrtp"></a>
mod_zrtp - ZRTP support functions</h3>
<div class="fragment"><pre class="fragment">
ZRTP support module

(C) 2014 Stefan Sayer.  Parts of the development of this module was kindly sponsored by AMTEL Inc.

If SEMS is built with ZRTP support, a module mod_zrtp is created.

ZRTP may be individually enabled or disabled and configured in the DSM script by using
zrtp.setEnabled in the start event, for example
   import(mod_zrtp);
   initial state START;
   transition "start" START - start / {
    zrtp.setEnabled(false);
-- or, e.g.: zrtp.setAllowclear(false);
   } -&gt; sess_started;
   state sess_started;

This overrides the sems.conf enable_zrtp setting. 

NOTE: The setEnabled/setAllowclear/... actions have only effect in the start event!

ZRTP specific events can be used in DSM if $enable_zrtp_events is set to true:
  set($enable_zrtp_events=true); 
Then the zrtp.protocolEvent and zrtp.securityEvent can be handled specifically.

Actions
-------
zrtp.setEnabled(bool enabled)
  e.g. zrtp.setEnabled(true) or zrtp.setEnabled(false)

zrtp.setAllowclear(bool enabled)  - set ZRTP allowclear option, see ZRTP documentation
zrtp.setAutosecure(bool enabled)  - set ZRTP autosecure option, see ZRTP documentation
zrtp.setDisclosebit(bool enabled) - set ZRTP disclose_bit option, see ZRTP documentation

zrtp.getSAS(sas1_var,sas2_var) - get SAS strings
 to be used after the stream has gone secure, e.g. 
  transition "ZRTP event IS_SECURE" sess_started - zrtp.protocolEvent(#event==ZRTP_EVENT_IS_SECURE) / {
     zrtp.getSAS($sas1,$sas2);
     log(3, $sas1);
     log(3, $sas2);
   } -&gt; sess_started;

zrtp.getSessionInfo(varname) - get info about the session
  varname.sas_is_ready, varname.sas1, varname.sas2, varname.zid, varname.peer_zid, ...


zrtp.setVerified(string zid1, string zid2)   - set as verified
zrtp.setUnverified(string zid1, string zid2) - set as unverified

 e.g.  zrtp.getSessionInfo(zrtp);
       zrtp.setVerified($zrtp.zid,$zrtp.peer_zid);

Events
------

zrtp.protocolEvent - protocol event happened, only if enable_zrtp_events==true
 e.g. 
  zrtp.protocolEvent(#event==ZRTP_EVENT_IS_SECURE)

  #event    - event type
  #event_id - numeric event type (should not be used)
 
 see the libzrtp documentation, or /usr/include/libzrtp/zrtp_iface.h for
 event types. Important ones are
   ZRTP_EVENT_IS_SECURE, ZRTP_EVENT_NO_ZRTP, ZRTP_EVENT_IS_SECURE_DONE,
   ZRTP_EVENT_IS_CLEAR, ZRTP_EVENT_IS_PENDINGSECURE, 

  e.g. 
    transition "ZRTP event" sess_started - zrtp.protocolEvent / {
      logParams(3);
    } -&gt; sess_started;

zrtp.securityEvent - security event happened, only if enable_zrtp_events==true
 e.g. 
  zrtp.securityEvent(#event==ZRTP_EVENT_PROTOCOL_ERROR)

  #event    - event type
  #event_id - numeric event type (should not be used)

  ZRTP_EVENT_PROTOCOL_ERROR, ZRTP_EVENT_WRONG_SIGNALING_HASH, ZRTP_EVENT_WRONG_MESSAGE_HMAC,
  ZRTP_EVENT_MITM_WARNING
       
</pre></div> <h2><a class="anchor" id="Links"></a>
Links</h2>
<p>Back to <a class="el" href="AppDoc.html">Application Modules</a>, to <a class="el" href="AppDocExample.html">Example Applications</a>. </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
