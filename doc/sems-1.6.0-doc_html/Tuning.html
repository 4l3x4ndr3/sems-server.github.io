<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>SEMS: Tuning SEMS for high load</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">SEMS
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Tuning SEMS for high load </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>For high load, there are several compile and run time options to make SEMS run smoothly.</p>
<p>When running SEMS, make sure that you have the ulimit for open files (process.max-file-descriptor) set to an value which is high enough. You may need to adapt raise the system wide hard limit (on Linux see /etc/security/limits.conf), or run SEMS as super user. Note that an unlimited open files limit is not possible, but it is sufficient to set it to some very high value (e.g. ulimit -n 100000).</p>
<p>There is a compile-time variable that sets a limit on how many RTP sessions are supported concurrently, this is MAX_RTP_SESSIONS. You may either add this at compile time to your value, or edit Makefile.defs and adapt the value there.</p>
<p>SEMS normally uses one thread per session (processing of the signaling). This thread sleeps on a mutex (the session's event queue) most of the time (RTP/audio processing is handled by the <a class="el" href="classAmMediaProcessor.html" title="Media processing thread manager.">AmMediaProcessor</a> threads, which is only a small, configurable, number), thus the scheduler should usually not have any performance issue with this. The advantage of using a thread per call/session is that if the thread blocks due to some blocking operation (DB, file etc), processing of other calls is not affected. The downside of using a thread per session is that you will spend memory for the stack for every thread, which can fill up your system memory quickly, if you have many sessions. The default for the stack size is 1M, which for most cases is quite a lot, so if memory consumption is an issue, you could adapt this in <a class="el" href="classAmThread.html" title="C++ Wrapper class for pthread.">AmThread</a>, at the call to pthread_attr_setstacksize. Note that, at least in Linux, the memory is allocated, but if a page is not used, the page is not really consumed, which means that most of that empty memory space for the stack is not really consumed anyway. If you allocate more than system memory for stack, though, thread creation may still fail with ENOMEM. </p>
<p>You can compile SEMS with thread pool support (see Makefile.defs). This improves performance a lot for high CPS applications, e.g. signaling only B2BUA apps. You should NOT use threadpool if your applications use operations which could be blocking for a longer time (e.g. sleep, remote server access which could possibly be non-responsive), because one blocked session (call) is blocking all the other sessions (calls) that are processed by the same thread. So, for example, if the application logic of one call queries a server synchronously which takes a few seconds to respond, all the other calls are blocked from processing SIP messages and application logic during that time.</p>
<p>The reasons a thread pool gives a large performance boost over one-thread-per-call for high CPS applications presumably are that thread creation takes some time, and the thread scheduling is less efficient if there are very many active threads (as opposed to many sleeping threads like in usual media server applications, where the application/signaling threads sleep most of the time, while only the media/RTP processing threads are active).</p>
<p>On top of that, you save lots of memory (mostly the stack memory), also, because of STL memory allocator.  </p>
<p>If you notice retransmissions or even failing calls, but the CPU load is not at 100%, there may be several reasons for it:</p>
<ul>
<li>SIP messages are dropped when sending, because the NIC/network is not fast enough in accepting all the packets written to its queue and putting them on the network (you can check this with your OS, for newer Linux in /proc, check dropped packets on send for the SIP port)</li>
<li>there is contention on some mutexes -&gt; adapt EVENT_DISPATCHER_POWER in <a class="el" href="AmEventDispatcher_8h_source.html">AmEventDispatcher.h</a> -&gt; add striping for some other Mutexes  </li>
</ul>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
